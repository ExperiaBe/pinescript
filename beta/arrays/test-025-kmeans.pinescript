// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RicardoSantos

//@version=4
study("test-025-kmeans")

//| ---------------------------------------------------------------------------|
var float[] seed = array.new_float(size=1, initial_value=42.0)              //-|
f_prng(_range)=>                                                          //---|
//| pseudo random function:                                             // O O |
    var float _return = 1.0                                             //- V -|
    float _seed = array.get(id=seed, index=0)                            //NNNN|
    float _reseed =  271.828                                              // A |
    _return := ((3.1416 * _return % _seed) * _reseed) % _range            // V |
    array.set(id=seed, index=0, value=(1 + (_seed * 1.618) % _range) + _return) //||
    _return                                                                // ||
//| ---------------------------------------------------------------------------|

f_mdim_coord(_indices, _limits)=>
//| returns the flatten index of a array of N dimensions.
//|
//| https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays
//|     offset = n_D + N_D * ( ... (n_3 + N_3 * ( n_2 + N_2 * ( n_1 ) ) ) )
//|         D = number of dimensions    (1D=[0,1], 2D=[0,1][0,1], 3D=[0,1][0,1][0,1])
//|         n = indice in dimension     (3D=[2][1][1])
//|         N = limit in dimension      (3D=[3][3][3])
//|
//|         offset =                    (3D=[1][1][1]) in (3D=[2][2][2]) = (13) --> 1 + 3 × (1 + (3 × (1) ))
//|         offset =                    (3D=[1][2][1]) in (3D=[2][2][2]) = (16) --> 1 + 3 × (2 + (3 × (1) ))
//|         offset =                    (3D=[2][1][1]) in (3D=[2][2][2]) = (22) --> 1 + 3 * (1 + (3 * (2) ))
//|
    int _offset = 0
    // size of the arrays containing indices and dimensions
    int _i_size = array.size(id=_indices)
    int _l_size = array.size(id=_limits)
    // check for validity
    bool _size_match = _i_size == _l_size and _i_size > 0 and _l_size > 0
    if _size_match
        // last value in indices:
        _offset := array.get(id=_indices, index=0)
        // if higher than 1D array
        if _l_size > 1
            for _i = 1 to _l_size - 1
                int _ind = array.get(id=_indices, index=_i)
                int _dim = array.get(id=_limits, index=_i) + 1
                // to keep dimension size as base 0, for base 1 remove the '+ 1'
                _offset := _offset * _dim + _ind
    else
        _offset := na
    _offset

f_distance(_ax, _ay, _bx, _by)=>sqrt(pow(_ax - _bx, 2) + pow(_ay - _by, 2))

//| http://rosettacode.org/wiki/K-means%2B%2B_clustering

f_kmeans_cluster(_X, _Y, _number_of_clusters)=>
//| Returns the cluster centers for the given data.
//| -----------------------------------------------
//| Inputs:
//|     _X: array x data points
//|     _Y: array y data points
//|
//|     _number_of_clusters: number of clusters to find center.
//| -----------------------------------------------------------
//| 1:  setup and errors
    int _X_size = array.size(id=_X)
    int _Y_size = array.size(id=_X)
    bool _size_match = _X_size == _Y_size
    bool _has_nclusters = _number_of_clusters > 0
    bool _data_over_clusters = _X_size > _number_of_clusters

    float[] _centers_x = array.new_float(size=0, initial_value=0.)
    float[] _centers_y = array.new_float(size=0, initial_value=0.)
    int[] _centers_count = array.new_int(size=_number_of_clusters, initial_value=0)
    
    float[] _distances = array.new_float(size=0, initial_value=0.)
    int[] _group = array.new_int(size=0, initial_value=0)
    
    if _has_nclusters and _data_over_clusters and _size_match
//| 2:  initial cluster centers
//|     can use alternative method of initialization (kmeans++, random) for now will only use random
        for _i = 0 to _number_of_clusters - 1
            int _value = int(f_prng(_X_size))
            array.push(id=_centers_x, value=array.get(id=_X, index=_value))
            array.push(id=_centers_y, value=array.get(id=_Y, index=_value))

//|     2.b: calculate distances to centers:
        for _i = 0 to _number_of_clusters - 1
            float _total_sum_of_distance = 0.0
            for _j = 0 to _X_size - 1
                float _x = array.get(id=_X, index=_j)
                float _y = array.get(id=_Y, index=_j)
                //  calculate distance to cluster and populate the _group
                int _min_group = 0
                float _min_distance = sqrt(pow(_x - array.get(id=_centers_x, index=0), 2) + pow(_y - array.get(id=_centers_x, index=0), 2))
                for _k = 1 to _number_of_clusters - 1
                    float _c_x = array.get(id=_centers_x, index=_k)
                    float _c_y = array.get(id=_centers_y, index=_k)
                    float _distance = sqrt(pow(_x - _c_x, 2) + pow(_y - _c_y, 2))//some examples did not sqrt
                    if _distance < _min_distance
                        _min_distance := _distance
                        _min_group := _k
                array.push(id=_group, value=_min_group)
                array.push(id=_distances, value=_min_distance)
                _total_sum_of_distance := _total_sum_of_distance + _min_distance
            
            _total_sum_of_distance := _total_sum_of_distance * f_prng(1.0)
            
            for _j = 0 to _X_size - 1
                _total_sum_of_distance := _total_sum_of_distance - array.get(id=_group, index=_j)
                if _total_sum_of_distance > 0
                    continue
                else
                    array.set(id=_centers_x, index=_i, value=array.get(id=_X, index=_j))
                    array.set(id=_centers_y, index=_i, value=array.get(id=_Y, index=_j))
                    break
            
//| 3:  Choose center with probability proportional to its squared distance from existing centers.
            for _j = 0 to _X_size - 1
                float _x = array.get(id=_X, index=_j)
                float _y = array.get(id=_Y, index=_j)
                //  calculate distance to cluster and populate the _group
                int _min_group = 0
                float _min_distance = sqrt(pow(_x - array.get(id=_centers_x, index=0), 2) + pow(_y - array.get(id=_centers_x, index=0), 2))
                for _k = 1 to _number_of_clusters - 1
                    float _c_x = array.get(id=_centers_x, index=_k)
                    float _c_y = array.get(id=_centers_y, index=_k)
                    float _distance = sqrt(pow(_x - _c_x, 2) + pow(_y - _c_y, 2))//some examples did not sqrt
                    if _distance < _min_distance
                        _min_distance := _distance
                        _min_group := _k
                array.set(id=_group, index=_j, value=_min_group)
                array.set(id=_distances, index=_j, value=_min_distance)                
//| 4:  find cluster centers.
        for _i = 0 to _X_size - 1
            float _x = array.get(id=_X, index=_i)
            float _y = array.get(id=_Y, index=_i)
            int _group_i = array.get(id=_group, index=_i)
            
            int _center_count = array.get(id=_centers_count, index=_group_i)
            float _center_x = array.get(id=_centers_x, index=_group_i)
            float _center_y = array.get(id=_centers_y, index=_group_i)
            array.set(id=_centers_count, index=_group_i, value=_center_count + 1)
            array.set(id=_centers_x, index=_group_i, value=_center_x + _x)
            array.set(id=_centers_y, index=_group_i, value=_center_y + _y)
        
        for _i = 0 to _number_of_clusters - 1
            int _center_count = array.get(id=_centers_count, index=_i)
            float _center_x = array.get(id=_centers_x, index=_i)
            float _center_y = array.get(id=_centers_y, index=_i)
            
            array.set(id=_centers_x, index=_i, value=_center_x / _center_count)
            array.set(id=_centers_y, index=_i, value=_center_y / _center_count)
    // missing part:
    // http://rosettacode.org/wiki/K-means%2B%2B_clustering
    //  python
    //     # find closest centroid of each PointPtr
    //     changed = 0
    //     for p in points:
    //         min_i = nearest_cluster_center(p, cluster_centers)[0]
    //         if min_i != p.group:
    //             changed += 1
    //             p.group = min_i
 
    //     # stop when 99.9% of points are good
    //     if changed <= lenpts10:
    //         break
 
    // for i, cc in enumerate(cluster_centers):
    //     cc.group = i

//| 6:  Output.
    [_centers_x, _centers_y]
//    [_group, _distances]

if barstate.isfirst
    array.set(id=seed, index=0, value=1337)

int[] X = array.new_int(size=0, initial_value=0)
float[] Y = array.new_float(size=0, initial_value=0)

for _i = 0 to 20
    array.push(id=X, value=bar_index[_i])
    array.push(id=Y, value=close[_i])

[g, d] = f_kmeans_cluster(X, Y, 3)
t = tostring(g) + '\n' + tostring(d)

var label debug = label.new(bar_index, 0.0, '')
label.set_xy(id=debug, x=bar_index, y=0.0)
label.set_text(id=debug, text=t)


//plot(f_distance(bar_index, close, bar_index[1], close[1]))